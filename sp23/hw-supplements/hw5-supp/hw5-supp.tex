\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumitem}

% colored links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    }



% Inputting Python code
\usepackage[dvipsnames]{xcolor}
\definecolor{textblue}{rgb}{.2,.2,.7}
\definecolor{textred}{rgb}{0.54,0,0}
\definecolor{textgreen}{rgb}{0,0.43,0}
\usepackage{upquote}
\usepackage{listings}
\lstset{
    language=Python, 
    tabsize=4,
    basicstyle={\ttfamily},
    keywordstyle=\color{textblue},
    commentstyle=\color{textgreen},
    stringstyle=\color{textred},
    frame=none,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    xleftmargin=-15mm, % manual adjustment, figure out permanent solution
}

%Creating algorithms
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{tcolorbox}
\tcbuselibrary{skins,hooks}
\usetikzlibrary{shadows}
\usepackage{lipsum}

%Images
\usepackage{graphicx}
    \usepackage{subcaption}
    \usepackage{float}
    % \usepackage[labelsep=period]{caption}

    
%Creating Figures
\usepackage{tikz}
\usetikzlibrary{calc, math, matrix, graphs, positioning}


% the settings of tikz is used for the optimization of the graphs  
\usetikzlibrary{shapes, arrows, calc, arrows.meta, fit, positioning} % these are the parameters passed to the library to create the node graphs  
\tikzset{  
    -Latex,auto,node distance =1.5 cm and 1.3 cm, thick,% node distance is the distance between one node to other, where 1.5cm is the length of the edge between the nodes  
    state/.style ={ellipse, draw, minimum width = 0.9 cm}, % the minimum width is the width of the ellipse, which is the size of the shape of vertex in the node graph  
    point/.style = {circle, draw, inner sep=0.18cm, fill, node contents={}},  
    bidirected/.style={Latex-Latex,dashed}, % it is the edge having two directions  
    el/.style = {inner sep=2.5pt, align=right, sloped}  
}  

%Formatting and Spacing
\setitemize[1]{noitemsep, parsep = 5pt, topsep = 5pt}
\setenumerate[1]{label = (\alph*), parsep = 1pt, topsep = 5pt}
\setlength\parindent{0pt}
\linespread{1.1}

% title
\title{\vspace{-1cm}CS 2051: Honors Discrete Mathematics \\Spring 2023 Homework 5 Supplement}
\author{Sarthak Mohanty }
\date{}

\begin{document}

\maketitle

\section*{Overview}
    \textbf{Note: This document and the autograder will be continuously updated until Monday morning, but the fundamentals remain the same.}

    % \vspace{2mm}
    % Traditionally, computer software has been written for serial computation: instructions corresponding to a tasks are executed on one processing unit at a time. However, nowadays many computational tasks consist of many elementary operations, some of which had to be computed sequentially, while others could be computed in parallel. 

  % In a distributed computing or high performance computing class, one of the first things you learn is \textbf{Amdahl’s law}, which gives a quantitative measure of the speedup $S$ -- i.e., how much faster the task can be performed by using $n$ parallel processors:
  % $$S = \frac{1}{1 - p + \frac{p}{n}}.$$ Here, $p$ is the proportion of operations that can be performed in parallel.

  %   \vspace{2mm}
  %   However, it is not typically the case that we can classify operations simply as “parallel” or “sequential.” Instead, a task might consist of several sub-tasks, some of which need to be completed before others are started. 

  %   \vspace{2mm}
  %   To understand this problem, we first have to develop some mathematical foundations. This week in your 2050 lecture, you learnt about functions, and how they represent mappings between two sets. 
    

    \vspace{2mm}
    In this supplement, you learn about a generalized form of functions known as \textbf{relations}, and explore the connection between functions and relations. You'll learn about equivalence relations and partial orders. You'll also explore some of the applications of these concepts
  %   \vspace{2mm}
  %   Finally, we'll cover scheduling with multiple processors. You'll learn how to apply the theory of partial ordering through code. We'll cover topics such as \textbf{chains}, \textbf{antichains}, and \textbf{Dilworth's Lemma}.




\section*{Part 1: Generalizing Functions with Relations}

    This week, you learned about functions. We (informally) defined them as a well-defined mapping between two sets. However, what about mappings that are not well-defined? Is there no way to represent these? As a matter of fact, there is!
    
    \vspace{3mm}
    \textbf{Definition} a \textit{relation} $\mathcal{R}$ over sets $A, B$ is a subset of $A \times B$. The notation $a\mathcal{R}b$ or $a \sim b$ is often used to denote that $(a, b) \in \mathcal{R}$.

    \subsection*{Examples}
    
    Let $\mathcal{R}_1, \dots, \mathcal{R}_4$ be a relation on $A = \{1, 2, 3, 4\}$.
    \begin{itemize}
        \item $\mathcal{R}_1 = \{(a, b) \mid a \le b)\}$
        \item $\mathcal{R}_2 = \{(a, b) \mid a = b)\}$
        \item $\mathcal{R}_3 = \{(a, b) \mid a+b \le 2022)\}$
        \item $\mathcal{R}_4 = \{(a, b) \mid a \text{ divides } b\}$
    \end{itemize}
    
\subsection*{Properties of a Relation }

    \begin{enumerate}[align=left]
        \item [\textbf{Reflexitivty}] $\mathcal{R}$ is \textit{reflexive} if 

        $(\forall a \in A)(a\mathcal{R}a)$
        \item [\textbf{Symmetry}] $\mathcal{R}$ is \textit{symmetric} if 

        $(\forall a, b \in A)(a\mathcal{R}b \iff b\mathcal{R}a)$

        \item [\textbf{Antisymmetry}] $\mathcal{R}$ is \textit{symmetric} if 

        $(\forall a, b\in A)(a\mathcal{R}b \wedge b\mathcal{R}a \rightarrow a=b)$

        \item [\textbf{Transitivity}] $\mathcal{R}$ is \textit{transitive} if 

        $(\forall a, b, c\in A)(a\mathcal{R}b \wedge b\mathcal{R}c \rightarrow a\mathcal{R}c)$
    \end{enumerate}

When a relation is reflexive, antisymmetric, and transitive, we call it a \textit{partial order}.

When a relation is reflexive, symmetric, and transitive, we call it a \textit{equivalence relation}.
% \subsection*{Check Your Understanding}


% \newtcolorbox{mybox}[2][]{colback=red!5!white,
% colframe=red!75!black,
% % fonttitle=\bfseries,
% colbacktitle=red!85!black,enhanced,
% attach boxed title to top center={yshift=-2mm},
% title={#2},#1}


% \begin{mybox}[colback=yellow]{\lstinline{relations.py}}
% This is my own box with a mandatory title
% and options.
% \end{mybox}

    \vspace{3mm}
    \begin{tcolorbox}[colback=yellow!30]
        In this part, you'll implement the functions \lstinline{isPartialOrder(elements, relation)} and \lstinline{isEquivalenceRelation(elements, relation)}. These functions takes in a relation (represented as a list of tuples) and returns whether or not the relation (taken over the set of elements) is a valid partial order or equivalence relation, respectively. You must use the following helper methods:
        \begin{itemize}
            \item \lstinline{isReflexive(elements, relation)}
            \item \lstinline{isSymmetric(elements, relation)}
            \item \lstinline{isAntisymmetric(elements, relation)}
            \item \lstinline{isTransitive(elements, relation)}
        \end{itemize}
        \textbf{All methods (and all helper methods) must be implemented in one line.}
        Hint: use \lstinline{all} method
    \end{tcolorbox}



\section*{Part 2: Partitioning with Equivalence Relations}
    In the world of computer science, there are two main applications for relations: partitioning and scheduling. In this part, we'll cover partitioning, which is essentially just a reframing of our knowledge about equivalence relations. If any of the concepts introduced in this section feel rather hand-wavy, feel free to consult the textbook, which has rigorous proofs for the theorems.

    \vspace{2mm}
    \textbf{Definition}: Given some relation $\mathcal{R}$ over the set $A$, the \textit{equivalence class} of an element $x \in A$ is $$[x] = \{y : x \mathcal{R} y\}$$

    There is a very powerful theorem related to this concept:

    \vspace{2mm}
    \textbf{Important Theorem}: The equivalence classes of an equivalence relation on a set $A$ \textit{partition} $A$ into a collection of disjoint, nonempty subsets $A_{1}, A_{2}, \dots, A_{n}$ such that (and this is the important part) $\bigcup _{i = 1}^{n} = A$.


    \vspace{2mm}
    Ok, so this fact is cool and all, but what's the point? Well, if we have say 

    \subsection*{Example 1: Congruence Relations}
        Our first example delves into \textit{number theory}, a field you will become more intimate with in the next few supplements. Informally, define the relation $a\mathcal{R}_{N}b$ over $\mathbb{Z} \times \mathbb{Z}$ if $a$ and $b$ have the same remainder when divided by some number $n$. We usually denote this using $$a \equiv b \pmod{n}.$$ 

        For example, $-10$ and $15$ are related under $\mathcal{R}_{5}$, $$-10 \equiv 15 \pmod{5}$$ since $-10 - 15 = -25$ is a multiple of $5$, or equivalently since both $-10$ and $15$ have the same remainder $0$ when divided by $5$.
        
        
        
        All such relations $\mathcal{R}_{n}$ are equivalence relations, and partition the set of integers into $n$ equivalence classes. For example, the relation $\mathcal{R}_{3}$ partitions the integers like so
        \begin{gather}
            \{\dots, -8, -5, -2, 1, 4, 7, \dots\} \\
            \{\dots, -7, -4, -1, 2, 5, 8, \dots\} \\
            \{\dots, -6, -3, 0, 3, 6, 9, \dots\}
        \end{gather}
        The canonical 


    \subsection*{Example 2: Vector Spaces}
        One of the most prominent uses of equivalence classes is in linear algebra. After all, it's very difficult to determine when two vector spaces or matrices are functionally ``identical". 

        \vspace{3mm}
        If you've taken an introductory linear algebra course, you learned about Gauss's Method to solve a system of equations. In essence, it worked by starting with a matrix and deriving a sequence of other matrices, each \textit{row equivalent} to each other. It turns out that row equivalence is an equivalence relation, and partitions the set of all matrices into corresponding classes, as shown in Figure (\ref{fig:2}).

        \vspace{3mm}
        We can generalize this one step further with a relation known as \textit{matrix equivalence}. Matrix equivalent matrices represent the same map, with respect to appropriate pairs of bases. Matrix equivalence classes are characterized by rank: two same-sized matrices are matrix equivalent if and only if they have the same rank. In fact, matrix similarity is a special case of matrix equivalence!

        \vspace{3mm}
         The canonical forms for row equivalence are the Reduced Echelon form matrices, which you may already be familiar with. Meanwhile, the canonical forms for matrix similarity are Jordan Normal forms. (the canonical forms for matrix equivalence are a bit more complicated.)
        
        \begin{figure}[H]
            \centering
            \begin{subfigure}{0.45\textwidth}
                \centering
                \includegraphics[scale = .3]{sp23/hw-supplements/hw5-supp/images/linalg_matrix_equivalence_classes.png}
            \end{subfigure}
            \begin{subfigure}{0.45\textwidth}
                \centering
                \includegraphics[scale = .36]{sp23/hw-supplements/hw5-supp/images/linalg_matrix_similarity_equiv_classes.png}
            \end{subfigure}
            \caption{Matrix similarity is a finer partition than matrix equivalence}
            \label{fig:1}
        \end{figure}

        \begin{figure}[H]
            \centering
            \begin{subfigure}{0.45\textwidth}
                \centering
                \includegraphics[scale = .22]{sp23/hw-supplements/hw5-supp/images/linalg_reduced_echelon_form_equiv_classes.png}
                \caption{Two matrices with the same row space.}
            \end{subfigure}
            \begin{subfigure}{0.45\textwidth}
                \centering
                \includegraphics[scale = .33]{sp23/hw-supplements/hw5-supp/images/linalg_2by2_rank_equivalence_classes.png}
                \caption{The canonical forms for the set of $2 \times 2$ matrices.}
            \end{subfigure}
            \caption{Row equivalence as an equivalence relation.}
            \label{fig:2}
        \end{figure}

    \vspace{3mm}
    \begin{tcolorbox}[colback=yellow!30]
        \textbf{In this part, you'll implement the following function:}
        \begin{itemize}
            \item \lstinline{partition(elements, relation)}: This function takes a equivalence relation (this time represented as a boolean function), and returns a partition of the elements into equivalence classes. For example, given the congruence relation described above, the function should return
        \begin{lstlisting}[belowskip=-10pt]
            >>> partition([i for i in range(-8, 8)], lambda x, y: (x - y) % 3 == 0)
            [{-6, -3, 0, 3, 6}, {-8, -5, -2, 1, 4, 7}, {-7, -4, -1, 2, 5, 8}]
        \end{lstlisting}

        \end{itemize}

        Tip: iterating over sets is difficult. Try casting.
    \end{tcolorbox}

    % idea: quotient graph https://networkx.org/documentation/stable/_modules/networkx/algorithms/minors/contraction.html#equivalence_classes

\section*{Part 3: Single Processor Task Scheduling}

    We now delve into partial orderings, or ``posets". We'll cover a nice ``graph"ical representation of posets, and then cover their applications in the context of task scheduling. 
    

    \subsection*{Dependency Graphs}
    
    To start, let's consider the following story. 

    \begin{tcolorbox}[colback=red!10]
        You're a recently admitted CS major at Georgia Tech. To save money, you're trying to graduate as early as possible.  You have a lot of course that you can take, but you're not sure which ones to take when. Furthermore, many of the courses are dependent upon completion of other courses (for example, CS 2110 requires CS 1331, which in turn requires CS 1301). How long will it take for you to graduate?
    \end{tcolorbox}

    We can represent this problem as a poset $\mathcal{R}$ over the set of courses $A$, where $a \mathcal{R} b$ iff $a$ is a prerequisite to take $b$:

    % (1301, 1331)

    % (1331, 1332)

    % (1331, 2110)

    % (2051, 3511)

    % (1332, 3511)

    % (1332, 3600)

    \begin{center}
    \begin{tikzpicture}[scale = 0.7, transform shape]  
        % a is the name of the node and A is the text inside the node/vertex  
        \node[state] (1301) at (0,0) {1301}; % here, state signifies that the shape of the node will be the shape declared in the above state/.style command.  
      
        % you can mention any location such as right, left, above, below, etc.  
         
        \node[state] (1331) [below =of 1301] {1331};  
        \node[state] (1332) [below =of 1331] {1332};
        \node[state] (2051) [right =of 1332] {2051};  
        \node[state] (2110) [below left =of 1332] {2110};  
        \node[state] (3600) [below =of 1332] {3600};  
        \node[state] (3511) [below right =of 1332] {3511};  
        \path (1301) edge (1331); % it is the path of the edge from one node to another  
        \path (1331) edge (1332);
        \path (1332) edge (2110);
        \path (1332) edge (3600);
        \path (1332) edge (3511);
        \path (2051) edge (3511);
      
        % % Bidirected edge  
        % \path[bidirected] (1331) edge[bend left=60] (1332); % this is the basic command in this code. It is used to draw the curved edge with a certain angle. You can change the angle according to the requirements.  
          
        % \path (a) edge (c);  
        %  \path[bidirected] (a) edge[bend right=60] (c);  
        %  \draw (b) -- (c);  
          
    \end{tikzpicture}  
    \end{center}
    This is known as a \textit{dependency graph}.



    % We can model these dependencies as a partial ordering. For example, the partial ordering (do one on classes) can be represented as a dependency graph, which in turn can be represented as a dependency list. (show illustration). Note how we


    \subsection*{Task Scheduling}
    
    Using the formalism of posets, we can also define the problem of computing an optimal schedule. We do so in the language of job scheduling, as it's the most common form. 

    \vspace{3mm} Assume that some task $T$ can be decomposed into sub-tasks $T = \{T_{1}, T_{2}, \dots, T_{n}\}$. In general, we can encode the relationships between the various $T_{i}$ as a poset, where $T_{i} \prec T_{j}$ if (sub)task $T_{i}$ needs to be performed before $T_{j}$. \textbf{Assume each task $T_{i}$ takes 1 unit of time to complete.} Given $k$ processors $P_{1}$, $P_{2}$, \dots, $P_{k}$ a \textbf{schedule} for $T$ assigns each sub-task $T_{i}$ a processor $P_{j}$ as well as a time $t_{i}$ at which $P_{j}$ shoudl start task $T_{i}$. Observe that if a processor starts $T_{i}$ at times $t_{i}$, then the task will complete at time $t_{i} + w_{i}$, where $w_{i}$ is the weight of $T_{i}$. A schedule is \textbf{feasible} if:

    \begin{enumerate}[label = \arabic*]
        \item no single processor is performing multiple tasks at the same time (i.e., if a processor is assigned $T_{i}$ at time $t_{i}$ and $T_{j}$ at time $t_{j} > t_{i}$, then $t_{j} \ge t_{i} + w_{i}$), and
        \item for every pair of tasks $T_{i}$ and $T_{j}$ with $T_{i} \prec T_{j}$, $T_{j}$ is schedule to start some time after (or at the same time) $T_{i}$ completes (i.e., $t_{j} \ge t_{i} + w_{i}$).
    \end{enumerate}


    

    If we have only one processor, then the answer is fairly simple, just create a topological sorting: Definition: A topological sorting is a total ordering of a partially ordered set.

    

    \begin{algorithm}
        \caption{\textsc{topological\_sort}$(poset)$}\label{alg:cap}
        \label{alg:topological_sort}
        \begin{algorithmic}
            \State $T = $ empty list
            \State $S = $ all minimal elements in $poset$
            \While{S is not empty}
            
                remove some node $u$ from $S$ and add it to $T$.

                \State $uv\_dependencies$ set of all dependencies of the form $(u, v)$ for some $v$.
                \For{each $(u, v)$ in $uv\_dependencies$}

                    \If {v is minimal}
                        Insert v in T
                    \EndIf

                \EndFor

            \EndWhile
            
                
            \State \Return{T}
        \end{algorithmic}
    \end{algorithm}


    \vspace{3mm}
    \begin{tcolorbox}[colback=yellow!30]
        \textbf{In this part, you'll implement the following function:}
        
        \lstinline{topological_sort(poset)}: This method takes in a partially ordered set in the form of a dependency list and returns a valid topological sort. 

        I'll be manually checking that you used some semblance of Kahn's algorithm in your solution, so don't use other approaches like a modified DFS (besides, it'll be more useful for the next part).

        Tip: The use of external data structures such as queues or stacks may be helpful (but not required) in completing this task.
    \end{tcolorbox}

\section*{Part 4: Multi-Processor Job Scheduling}

    \textbf{Definition} A \textit{chain} is such that every distinct pair of elements is comparable in $\mathcal{P}$.

    Note taht the time it takes to schedule tasks, even with an unlimited number of processors, is at least the length of the longest chain. Indeed, if we used less time, then two items from a longest chain would have to be done at the same time, which contradicts the precedence constraints. 



    The nice thing about posets is that this is always possible! In other words, for any poset, there is a legal paralle schedule that runs in $t$ steps, where $t$ is the length of the longest chain. This is known as Mirsky's theorem:


    


    
    If we have an unlimited number of processors, then the time to complete all tasks is equal to the length of the longest chain of dependent tasks. The case where there are a limited number of processors, however, is more useful in practice.

    % https://link.springer.com/article/10.1023/B:ORDE.0000034609.99940.fb


    \begin{tcolorbox}[colback=yellow!40]
        \lstinline{generate_schedule(poset, num_processors)}:  This method takes in a partially ordered set in the form of a dependency list and returns a valid schedule in the form of a list of lists, where the $i$-th element in the list represents the jobs we should schedule at time $t = i$.
    \end{tcolorbox}





% \section*{Conclusion}
%         In the previous section, you were given infinite processors. However, this is not always the case, and there are many situations when we need to minimize the number of machines working on a certain task.

    
%         In the previous section, you devised a method to find the height of a poset. A natural question then, is how to find the \textit{width} of a poset. While this problem seems simple on the surface, it is actually much more difficult. 
        
%     \subsubsection*{Incorrect Approach}

%     using the previous section, i'm sure many of you are picturing the following approach
    
%     apply a topological sort on the DAG
%     traverse over the nodes by the topological order, calculate the minimum level:
%     no parents: 0
%     otherwise: minimum parent level + 1
%     return the max level width (max num of nodes assigned the same level).

%     However, this approach does not always work. For a salient counterexample, consider a tree.

%     also discuss how bfs wouldnt work

%     % \textbf{Note: From this point onwards, we depart from the usual land of long-estabished results, and move on to areas of ongoing research.}

%     For example, the tools used to solve these problems are used in real life for countless companies (see https://github.com/google/or-tools)

% more further reading: https://foreseeable.github.io/AppliedAlgorithmCourseWebsite/scheduling1.pdf


\section*{Submission Instructions (10 pts)}
    After you fill the appropriate functions, submit the following files to Gradescope and make sure you pass all test cases:
    \begin{itemize}
        \item \lstinline{relations.py}
        \item \lstinline{scheduler.py}
    \end{itemize}

    \vspace{3mm}
    \textbf{Notes}

    \begin{itemize}
        \item The autograder may not reflect your final grade on the assignment. We reserve the right to run additional tests during grading.
        \item Do not import additional packages, as your submission may not pass the test cases or manual review.
    \end{itemize}

    

\end{document}