\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumitem}

% colored links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    }


% Inputting Python code
\usepackage[dvipsnames]{xcolor}
\definecolor{textblue}{rgb}{.2,.2,.7}
\definecolor{textred}{rgb}{0.54,0,0}
\definecolor{textgreen}{rgb}{0,0.43,0}
\usepackage{upquote}
\usepackage{listings}
\lstset{
    language=Python, 
    tabsize=4,
    basicstyle={\ttfamily},
    keywordstyle=\color{textblue},
    commentstyle=\color{textgreen},
    stringstyle=\color{textred},
    frame=none,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    xleftmargin=-15mm, % manual adjustment, figure out permanent solution
}

%Creating algorithms
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{tcolorbox}
\tcbuselibrary{skins,hooks}
\usetikzlibrary{shadows}
\usepackage{lipsum}

%Images
\usepackage{graphicx}
    \usepackage{subcaption}
    \usepackage{float}
    % \usepackage[labelsep=period]{caption}

%Formatting and Spacing
\setitemize[1]{noitemsep, parsep = 5pt, topsep = 5pt}
\setenumerate[1]{label = (\alph*), parsep = 1pt, topsep = 5pt}
\setlength\parindent{0pt}
\linespread{1.1}

% title
\title{\vspace{-1cm}CS 2051: Honors Discrete Mathematics \\Spring 2023 Homework 5 Supplement}
\author{Sarthak Mohanty }
\date{}

\begin{document}

\maketitle

\section*{Overview}
    Traditionally, computer software has been written for serial computation: instructions corrresponding to a tasks are executed on one processing unit at a time. However, nowadays many computational tasks consist of many elementary operations, some of which had to be computed sequentially, while others could be computed in parallel. 

  In a distributed computing or high performance computing class, one of the first things you learn is \textbf{Amdahl’s law}, which gives a quantitative measure of the speedup $S$ -- i.e., how much faster the task can be performed by using $n$ parallel processors:
  $$S = \frac{1}{1 - p + \frac{p}{n}}.$$ Here, $p$ is the proportion of operations that can be performed in parallel.

    \vspace{2mm}
    However, it is not typically the case that we can classify operations simply as “parallel” or “sequential.” Instead, a task might consist of several sub-tasks, some of which need to be completed before others are started. 

    \vspace{2mm}
    To understand this problem, we first have to develop some mathematical foundations. This week in your 2050 lecture, you learnt about functions, and how they represent mappings between two sets. 
    

    \vspace{2mm}
    In this supplement, you learn about a generalized form of functions known as \textbf{relations}, and explore the connection between functions and relations. 

    \vspace{2mm}
    We'll then move on to some basic scheduling, and along the way introduce one of the most important concepts in discrete mathematics: \textbf{graph theory}. You'll learn about \textbf{greedy algorithms}, as well as how to perform a \textbf{topological sorting} on a graph. You'll also tie the knot linking relations, functions, and graphs together.

    \vspace{2mm}
    Next, we'll cover scheduling with multiple processors. You'll learn how to apply the theory of partial ordering through code. We'll cover topics such as \textbf{chains}, \textbf{antichains}, and \textbf{Dilworth's Lemma}.




\section*{Part 1: Relations, Partial Orders, and Graphs}

    Recall the definition of a relation:
    
    \vspace{1.5mm}
    \textbf{Definition} a \textit{relation} is a subset of the Cartesian product $A\times B$.
    
    \vspace{1.5mm}
    We denote relations by $\mathcal{R}$. We write $a\mathcal{R} b$ to indicate that $(a,b)\in \mathcal{R}$ (i.e.: in the subset denoted by $\mathcal{R}$). When $A=B$ we said that $\mathcal{R}$ is a relation on $A$.\\

    Examples.
    
    Let $\mathcal{R}_1, \dots, \mathcal{R}_4$ be a relation on $A = \{1, 2, 3, 4\}$.
    \begin{itemize}
        \item $\mathcal{R}_1 = \{(a, b) \mid a \le b)\}$
        \item $\mathcal{R}_2 = \{(a, b) \mid a = b)\}$
        \item $\mathcal{R}_3 = \{(a, b) \mid a+b \le 2022)\}$
        \item $\mathcal{R}_4 = \{(a, b) \mid a \text{ divides } b\}$
    \end{itemize}
    So why relations? They are more general and allow us to study more complex sets. Elaborate. \\
    
\subsection*{Properties}
    
    \begin{itemize}
        \item \underline{Reflexive:} $(\forall a \in A)(a\mathcal{R}a)$
        \item \underline{Symmetric:} $(\forall a, b \in A)(a\mathcal{R}b \iff b\mathcal{R}a)$
        \item \underline{Antisymmetric:} $(\forall a, b\in A)(a\mathcal{R}b \wedge b\mathcal{R}a \rightarrow a=b)$
        \item \underline{Transitive:} $(\forall a, b, c\in A)(a\mathcal{R}b \wedge b\mathcal{R}c \rightarrow a\mathcal{R}c)$
    \end{itemize}
When a relation is reflexive, antisymmetric, and transitive, we call it a \textit{partial order}.

% \subsection*{Check Your Understanding}

    \vspace{3mm}
    \textbf{In this part, you'll implement the following function:}
    \begin{tcolorbox}[colback=blue!10]
        \begin{itemize}
            \item \lstinline{isPartialOrder(relation)}: This function takes in a relation (represented as a list of tuples) and returns whether or not the relation is a valid partial order. This method should be a one-liner after you complete the following helper methods:
            \begin{itemize}
                \item \lstinline{isReflexive(relation)}
                \item \lstinline{isAntisymmetric(relation)}
                \item \lstinline{isTransitive(relation)}
            \end{itemize}
            \item \lstinline{isEquivalenceRelation(relation)}: This function takes in a relation (represented as a list of tuples) and returns whether or not the relation is a valid partial order. This method should be a one-liner after you complete the following helper methods:
            \begin{itemize}
                \item \lstinline{isReflexive(relation)}
                \item \lstinline{isSymmetric(relation)}
                \item \lstinline{isTransitive(relation)}
            \end{itemize}
        \end{itemize}
        %     \begin{lstlisting}[belowskip=-10pt]
        %         >>> infer(['p |implies| q', 'p'], 'q')
        %         True
        %     \end{lstlisting}
        Here's the tricky part: all methods must be implemented in one line.
    \end{tcolorbox}



\section*{Part 2: Partitioning with Equivalence Relations}
    In the world of computer science, there are two main applications for relations: partitioning and scheduling. The partitioning aspect deals with equivalence relations, and we won't cover it in this supplement (add a footnote here about places they can find it. 



    \vspace{3mm}
    \textbf{In this part, you'll implement the following function:}
    \begin{tcolorbox}[colback=blue!10]
        \begin{itemize}
            \item \lstinline{partition(elements, relation)}: This function takes an iterable (link) elements and a boolean function relation, and returns a list of equivalence classes. For example, given the modulus equivalence relation described above, the function should return.

            %     \begin{lstlisting}[belowskip=-10pt]
        %         >>> infer(['p |implies| q', 'p'], 'q')
        %         True
        %     \end{lstlisting}

            We can even test it on the similariy relation:
            %     \begin{lstlisting}[belowskip=-10pt]
        %         >>> infer(['p |implies| q', 'p'], 'q')
        %         True
        %     \end{lstlisting}
        \end{itemize}
    \end{tcolorbox}

\section*{Part 3: Single-Processor Task Scheduling with Dependencies}

    As before, we introduce the problem with a story. 


    We can model these dependencies as a partial ordering. For example, the partial ordering (do one on classes) can be represented as a dependency graph, which in turn can be represented as a dependency list. (show illustration). Note how we

    Definition: A topological sorting is a total ordering of a partially ordered set.

    


    There is a very simple solution to this problem, known as Kahn's algorithm (add footnote here about more efficient version introduced in CS 3510/3511) . It works as follows:

    Count and store the in-degrees of all nodes in a graph. The in-degree of a node A is the number of edges that have A as the target or destination.
Identify nodes with an in-degree of 0. Add each node to a set that will be iterated over and append each node to a list that will contain the sorted nodes.
While the set containing nodes with an in-degree of 0 is not empty, remove a node. For each node removed, iterate over its edges, decrementing the stored in-degree of each destination node in the edge. If a node now has an in-degree of 0, add it to the set and list per step 2.
Finally, return the list each node is appended to. This will contain a topological ordering of the nodes.

\textbf{Your task is as follows:}

    \vspace{3mm}
    \textbf{In this part, you'll implement the following function:}
    \begin{tcolorbox}[colback=blue!10]
        \lstinline{topological_sort(poset)}: This method takes in a partially ordered set and returns a valid topological sort.
    \end{tcolorbox}

\section*{Part 4: Multi-Processor Task Scheduling with Dependencies}

    % https://link.springer.com/article/10.1023/B:ORDE.0000034609.99940.fb

    Using the formalism of posets, we can now define the problem of computing an optimal schedule. We do so in the langauge of parallel computation, as that is its most common habitat. 
    
    
    \vspace{3mm} Assume that some task $T$ can be deocmposed into sub-tasks $T = \{T_{1}, T_{2}, \dots, T_{n}\}$. In general, we can encode the relationships between the various $T_{i}$ as a poset, where $T_{i} \prec T_{j}$ if (sub)task $T_{i}$ needs to be performed before $T_{j}$. \textbf{Assume each task $T_{i}$ takes 1 unit of time to complete.} Given $k$ processors $P_{1}$, $P_{2}$, \dots, $P_{k}$ a \textbf{schedule} for $T$ assigns each sub-task $T_{i}$ a processor $P_{j}$ as well as a time $t_{i}$ at which $P_{j}$ shoudl start task $T_{i}$. Observe that if a processor starts $T_{i}$ at times $t_{i}$, then the task will complete at time $t_{i} + w_{i}$, where $w_{i}$ is the weight of $T_{i}$. A schedule is \textbf{feasible} if:

    \begin{enumerate}[label = \arabic*]
        \item no single processor is performing multiple tasks at the same time (i.e., if a processor is assigned $T_{i}$ at time $t_{i}$ and $T_{j}$ at time $t_{j} > t_{i}$, then $t_{j} \ge t_{i} + w_{i}$), and
        \item for every pair of tasks $T_{i}$ and $T_{j}$ with $T_{i} \prec T_{j}$, $T_{j}$ is schedule to start some time after (or at the same time) $T_{i}$ completes (i.e., $t_{j} \ge t_{i} + w_{i}$).
    \end{enumerate}

    \subsection*{Dual Dilworth's Theorem}


    \begin{tcolorbox}[colback=blue!10]
        \lstinline{find_critical_path(relation)}: 
    \end{tcolorbox}


    % https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/efac321fdc8d0b27586ca35b04aab808_MIT6_042JF10_chap07.pdf




\section*{(Optional) Dilworth's Theorem}
        In the previous section, you were given infinite processors. However, this is not always the case, and there are many situations when we need to minimize the number of machines working on a certain task.

    
        In the previous section, you devised a method to find the height of a poset. A natural question then, is how to find the \textit{width} of a poset. While this problem seems simple on the surface, it is actually much more difficult. 
        
    \subsubsection*{Incorrect Approach}

    using the previous section, i'm sure many of you are picturing the following approach
    
    apply a topological sort on the DAG
    traverse over the nodes by the topological order, calculate the minimum level:
    no parents: 0
    otherwise: minimum parent level + 1
    return the max level width (max num of nodes assigned the same level).

    However, this approach does not always work. For a salient counterexample, consider a tree.

    also discuss how bfs wouldnt work
%     % title={The title},
%     \begin{tcolorbox}[enhanced,watermark graphics=images/circuit,
%     watermark opacity=0.7,watermark stretch=1, watermark overzoom = 1.2]
%         \color{white}

%         \textbf{Your task is as follows:}
        
        
%         \vspace{3mm}
%         \lipsum[4]

%         \vspace{3mm}
%         \lipsum[3]
%     \end{tcolorbox}

    % \textbf{Note: From this point onwards, we depart from the usual land of long-estabished results, and move on to areas of ongoing research.}

    For example, the tools used to solve these problems are used in real life for countless companies (see https://github.com/google/or-tools)


\section*{Submission Instructions (10 pts)}
    After you fill the appropriate functions, submit the following files to Gradescope and make sure you pass all test cases:
    \begin{itemize}
        \item \lstinline{relations.py}
        \item \lstinline{scheduler.py}
    \end{itemize}

    \vspace{3mm}
    \textbf{Notes}

    \begin{itemize}
        \item The autograder may not reflect your final grade on the assignment. We reserve the right to run additional tests during grading.
        \item Do not import additional packages, as your submission may not pass the test cases or manual review.
    \end{itemize}

    

\end{document}