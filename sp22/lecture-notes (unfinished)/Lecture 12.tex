\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumitem}

%Vertical Dots in Align Environment
\usepackage{mathtools}

\usepackage{algorithm}
\usepackage{algpseudocode}

%Formatting and Spacing
\setitemize[1]{noitemsep, parsep = 5pt, topsep = 5pt}
\setenumerate[1]{label = (\alph*), parsep = 1pt, topsep = 5pt}
\setlength\parindent{0pt}
\linespread{1.1}

%Custom Title Fields
\newcommand{\lectTitle}{Lecture 12 Notes}
\newcommand{\lectTime}{February 21, 2022}
\newcommand{\lectClass}{Honors Discrete Mathematics}
\newcommand{\lectClassInstructor}{Gerandy Brito}
\newcommand{\lectSection}{Spring 2022}
\newcommand{\lectAuthorName}{Sarthak Mohanty}

%Headers and Footers
\usepackage{fancyhdr}
\usepackage{extramarks}
\pagestyle{fancy}
\lhead{\lectTime}
\chead{\lectClass \ (\lectClassInstructor)}
\rhead{\lectTitle}
\cfoot{\thepage}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\title{
    \vspace{2in}
    \textbf{\lectClass:\\ \lectTitle}\\
    \vspace{0.1in}\large{\textit{\lectClassInstructor\ \lectSection}}
    \vspace{3in}
    \author{\textbf{\lectAuthorName}}
    \date{}
}

\begin{document}

\maketitle
\pagebreak

\section*{Algorithmic Analysis}
    In Computer Science, one of the main goals is to find algorithms that are fast, or \textit{efficient}. Usually we can write these algorithms in the form $T(n)$ as the number of operations (worst case!) for an input of size $n$.
    
    \vspace{1.5mm}
    In prior CS courses, you have probably considered the best-case, average-case, and worst-case runtime of algorithms. In this course, however, we will usually consider only the worst-case runtime.
    
    \vspace{1.5mm}\textbf{TA Remark.} There are a few reasons for this. The following are taken from CLRS. 
    \begin{itemize}
        \item The worst-case running time of an algorithm gives us an upper bound on the runtime time for any input. Knowing it provides a guarantee that the algorithm will never take any longer. We need not make some educated guess about the running time and hope that it never gets much worse.
        \item For some algorithms, the worst case occurs fairly often. For example, in searching a database for a particular piece of information, the searching algorithm's worst case will often occur when the information is not present in the database. In some applications, searches for absent information may be frequent.
        \item The ``average case" is often roughly as bad as the worst case. Suppose that we randomly choose $n$ numbers and apply insertion sort. How long does it take to determine where in subarray $A[1\dots, j - 1]$ to insert element $A[j]$? on average, half the elements in $A[1, \dots, j - 1]$ to insert element $A[j]$? On average, half the elements in $A[1\dots, j - 1]$ are less than $A[j]$, and half the elements are greater. On average, therefore, we check half of the subarray $A[1, \dots, j - 1]$ and so $t_{j}$ is about $\frac{j}{2}$. The result average-case running time turns out to be a quadratic function of the input size, just like the worst-case running time.
    \end{itemize}
    
\subsection*{Recursive Algorithms}
    \textbf{Definition}. A \textit{recurrence} is an equation or inequality that describes a function in terms of its value on smaller inputs.
    
    \vspace{1.5mm}
    Recursive algorithms can come in many forms:
    \begin{itemize}
        \item A recursive algorithm that loops through the input to eliminate one item, such as the example we will show below.
        \item A recursive algorithm that divides the input into halves or more parts. Such algorithms are commonly known as divide-and-conquer algorithms, and will be explored further in CS 3510/3511.
    \end{itemize}
    
    Our goal in this course will be to 1) derive a recurrence formula from the given recursive algorithm and 2) solve the recurrence formula to find an explicit, or \textit{closed-form}, expression of the recurrence.
    
    \vspace{1.5mm}
    To illustrate this, let us return to topological sorting. Recall that for any poset $(S, \subseteq)$, a topological sorting can be found using the following algorithm
    \begin{enumerate}[label = \arabic*.]
        \item Find a minimal element of $S$, $s_{1}$.
        \item Iterate on $S \setminus \{s_{1}\}$.
    \end{enumerate}
    For some poset of size $n$, step 1 takes $n - 1$ comparisons. Hence the runtime is of the form $$T(n) = T(n - 1) + n  - 1,\ T(1) = 0.$$ Now we will attempt to solve the recurrence relation. There are many methods for doing so; in this course, we will cover two of them: the \textit{iteration method} and the \textit{substitution method}.

\subsection*{Iteration Method}
    Note that 
    $$\begin{aligned}[t]
        T(n) &= T(n - 1) + n - 1 \\
        &= (T(n - 2) + n - 2) + n - 1 \\
        &= T(n - 3) + (n - 3) + (n - 2) + (n - 1) \\
        &\vdotswithin{ = } \\
        &= T(1) + 1 + 2 + \dots + (n - 1) \\
        &= \textstyle\sum_{i = 1}^{n - 1} i = \tfrac{(n - 1)n}{2}.
    \end{aligned}$$
    
\subsection*{Substitution Method}
    Using repeated substitutions, we have
    \begin{align*}
        T(1) &= 0 = \tfrac{(1 - 1) \cdot 1}{2}, \\
        T(2) &= T(1) + 2 - 1 = 1 = \tfrac{(2 - 1) \cdot 2}{2}, \\
        T(3) &= T(2) + 3 - 1 = 3 = \tfrac{(3 - 1) \cdot 3}{2}, \\
        &\vdotswithin{ = } \\
        T(n) &= T(n - 1) + n - 1 = \tfrac{(n - 1)n}{2}.
    \end{align*}
    We prove the $n$-th term guess by mathematical induction. Let $P(n)$ be the statement $$T(n) = \tfrac{(n - 1)n}{2}.$$
    \textsc{Base Case}: $P(1)$ is true, since $T(1) = 0 = \tfrac{(1 - 1) \cdot 1}{2}$. \\
    \textsc{Inductive Step}: Now let $n \in \mathbb{N}$ such that $P(n)$ is true. Then $T(n + 1) = T(n) + n = \tfrac{(n - 1)n}{2} + n = \tfrac{(n + 1)(n)}{2}$, so $P(n + 1)$ is true as well. \\
    \textsc{Conclusion}: Therefore by induction, for all $n \ge 1$, $P(n)$ is true.
    
\subsection*{Calculator Example}
    We have a calculator, with two inputs given by : $a \in \mathbb{R} \setminus \{0\}$ and $n \in \mathbb{N}$. The output is given by $a^{n}$.
    
    To create this output, the calculator executes the following function
    \begin{algorithm}
    \caption{Calculator($a$, $n$)}\label{alg:Calc1}
    \begin{algorithmic}
        \If{$n = 1$}
            \State output $a$
        \ElsIf{$n > 1$}
            \State Calculator(a, n - 1) times a
        \EndIf
    \end{algorithmic}
    \end{algorithm}

    \vspace{1.5mm}
    \textbf{TA Remark.} There is no coding prerequisite for this course. Any pseudocode given on homeworks/exams should be easily understandable.
    
    \vspace{1.5mm}
    The recurrence formula for this algorithm is $$T(n) = T(n - 1) + 1.$$ It is left as an exercise for the students to find that $T(n) = n$.
    
    \vspace{1.5mm}
    Consider another calculator function:
    \begin{algorithm}
    \caption{Calculator($a$, $n$)}\label{alg:Calc2}
    \begin{algorithmic}
        \If{$n = 1$}
            \State return $a$
        \ElsIf{$n$ is even}
            \State $cal(a, \tfrac{n}{2}) \times Cal(a, \tfrac{n}{2}$.
        \ElsIf{$n$ is odd}
            \State $cal(a, \tfrac{n - 1}{2}) \times cal(a, \tfrac{n - 1}{2}) \times a$
        \EndIf
    \end{algorithmic}
    \end{algorithm}
    
    The recurrence formula for this algorithm is $T(n) \le T(n/2) + 2 (2 is worst case)$. Consider $n = 2^{k}$. Then $$T(n) = T(\tfrac{n}{2}) + 1, T(1) = 0.$$
    We will first solve this recursion using the iteration method. Note that
    $$\begin{aligned}[t]
        T(n) &= T(\tfrac{n}{2}) + 1 \\
        &= \left(T(\tfrac{n}{4}) + 1\right) + 1 \\
        &= \left(T(\tfrac{n}{8}) + 1\right) + 1 + 1 \\
        &\vdotswithin{ = } \\
        &= T(\tfrac{n}{2^{k}}) + k.
    \end{aligned}$$
    Let $2^{k} = n$, then $k = \log_{2}(n)$, so 
    $$\begin{aligned}[t]
        T(n) &= T(1) + \log_{2}(n) = \log_{2}(n).
    \end{aligned}$$
    We can also use the substitution method to obtain the same answer. Using repeated substitutions, we have
    \begin{align*}
        T(1) &= 0 = \log_{2}(1), \\
        T(2) &= T(1) + 1 = 1 = \log_{2}(2), \\
        T(4) &= T(2) + 1 = 2 = \log_{2}(4), \\
        &\vdotswithin{ = } \\
        T(n) &= T(\tfrac{n}{2}) + 1 = \log_{2}(n).
    \end{align*}
    Let $P(k)$ be the statement $$T(n) = \log_{2}(n) \text{, where $n = 2^{k}$}$$
    \textsc{Base Case}: $P(0)$ is true, since $T(0) = 0 = \log_{2}(1)$ \\
    \textsc{Inductive Step}: Now let $k \in \mathbb{N}$ such that $P(k)$ is true. Then $T(2^{k + 1}) = T(\tfrac{2^{k + 1}}{2}) + 1 = T(2^{k}) + 1$. So $P(k + 1)$ is true as well. \\
    \textsc{Conclusion} Therefore by induction, for all $k \ge 1$, $P(k)$ is true.

\end{document}